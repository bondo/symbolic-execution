\documentclass[11pt]{report}
%\documentclass[twoside,11pt,openright]{report}

\usepackage[utf8]{inputenc}
\usepackage[american]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{color}
\usepackage{datetime}

\renewcommand*\ttdefault{txtt}

\newcommand{\todo}[1]{{\color[rgb]{.5,0,0}\textbf{$\blacktriangleright$#1$\blacktriangleleft$}}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
{\Huge\sf Symbolic execution of Python 3}\\[2ex]
{\huge\sf Bjarke Bondo Andersen, 20096300}\\[2ex]
\noindent\rule{\linewidth}{1mm}\\[4ex]
\noindent{\Large\sf Project work, Computer Science\\[1ex] 
\monthname\ \the\year  \\[1ex] Advisor: Anders MÃ¸ller\\[15ex]}\\[\fill]}
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}
\todo{\dots}

\setcounter{tocdepth}{1}
\tableofcontents
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{ch:intro}

Symbolic execution is a way to prove existence of errors in programs.

\todo{Motivation: Dynamic languages are hard to analyze statically, as
  far as we know no one has implemented symbolic execution for Python
  before}

\section{Simple example}
\todo{\dots}

\section{Project goals}
\begin{itemize}
  \item \todo{Find out about symbolic execution and how it can be
    applied to Python}
  \item \todo{See if this strategy of source level transformations is
    a fruitful}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Overview}
\label{ch:overview}

\begin{itemize}
  \item \todo{Implementation strategy / general design decisions}
  \item \todo{Diagram explaining how the different program components
    fit together}
  \item \todo{Link to GitHub}
  \item \todo{Report structure}
  \item \todo{We started out by implementing an interpreter...}
\end{itemize}

The normalization and the insertion of instrumentation code is
implemented in Haskell \todo{Why?}. We use the \verb|Language.Python|
package to parse and pretty-print Python code.

For the actual symbolic execution, we have written a library/wrapper
in Python. We use Microsoft's SMT solver Z3 to solve constraints,
because it has a simple Python interface and can handle quite complex
constraints.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Background}
\label{ch:background}

\section{DART/CUTE}
\todo{\dots}

\section{Apollo}
\todo{\dots}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Normalization}
\label{ch:norm}

We do a normalization in which statements and expressions are
transformed into \emph{atomic actions}. For example, expressions are
transformed into a single action on local variables and a list of
statements that assign the value of the subexpressions into
corresponding variables. \todo{Elaborate}

Example: \verb!a + b * 4! is transformed into the following list of
preceding statements
\begin{verbatim}
tmp_1 = 4
tmp_2 = b * tmp_1
\end{verbatim}
and the expression \verb!a + tmp_2!

\section{Supported language}
For now, only a subset of Python 3 is supported. This section will
list supported/unsupported expression and statement AST nodes.
\todo{This would probably be nicer to read as a BNF}

\subsection{Supported expressions}
\begin{description}
  \item[Var:] Variables
  \item[Int, LongInt, Float, Imaginary, Bool, Tuple, List and Set:]
    Literals of the obvious kind.
  \item[None:] The \verb|None| literal.
  \item[Ellipsis:] The \verb|Ellipsis| literal.
  \item[ByteStrings, Strings and UnicodeStrings:] String literals.
  \item[Call:] Function calls. This does not include method calls,
    which are represented as a BinaryOp with operator Dot. This is
    also supported, though.
  \item[BinaryOp:] The application of a binary operator. Chained
    comparisons are not supported yet.
  \item[UnaryOp:] The application of a unary operator.
  \item[Paren:] Parenthesized expressions.
\end{description}

\subsection{Unsupported expressions}
\begin{description}
  \item[Subscript:] Expressions like \verb|x[y]|.
  \item[SlicedExpr:] Expressions like \verb|w[x:y:z]|.
  \item[CondExpr:] \verb|if|-\verb|then|-\verb|else| expressions.
  \item[Lambda:] Lambda expressions.
  \item[Yield:] The \verb|Yield| operator.
  \item[Generator:] Generators.
  \item[Dictionary:] Dictionary literals.
  \item[ListComp, DictComp and SetComp:] List, dictionary and set
    comprehensions.
  \item[Starred:] Expressions prefixed by a \verb|*|.
\end{description}

\subsection{Supported statements}
\begin{description}
  \item[Import and ImportFrom:] Import statements.
  \item[While:] While loops. Only supported when the condition is a variable.
  \item[For:] For loops.
  \item[Fun:] Function declarations.
  \item[Class:] Class declarations.
  \item[Conditional:] \verb|if|-\verb|elif|-\verb|else| chains.
  \item[Assign:] Normal assignment.
  \item[AugmentedAssign:] Assignments like \verb|a += b|.
  \item[Return, Pass, Break, Continue, Global, NonLocal and Assert:] Statements of the same name.
  \item[StmtExpr:] Statements consisting of an expression.
\end{description}

\subsection{Unsupported statements}
\begin{description}
  \item[Decorated:] Decorated statements, i.e. a statement prefixed by \verb|@something|.
  \item[Try:] \verb|try|-\verb|except|-\verb|finally| statements.
  \item[Raise:] Raise an exception.
  \item[With:] Automated resource handling.
  \item[Delete:] Delete something, like the delete operator in
    ECMAScript.
  \item[Exec:] Compile and execute code on the fly, analogous to eval
    in ECMAScript.
\end{description}

\section{Normalizing {\tt if-elif-else}}
Assume we have a function $$simplifyToVariable: Expression \rightarrow
[Statement] \times Variable$$ that transforms an arbitrary expression
into a list of normalized statements, and a variable containing the
final value of the expression.

If we now have that $(stmts, var) = simplifyToVariable(t1)$, we can
normalize an \verb!if!-\verb!elif! chain
\begin{verbatim}
if t1:
  S1
elif t2:
  S2
elif t3:
  S3
else
  S4
\end{verbatim}
by first transforming it into a single \verb!if!-statement with the rest of the
\verb!if!-\verb!elif! chain in the \verb!else! clause
\begin{verbatim}
stmts
if var:
  S1
else
  if t2:
    S2
  elif t3:
    S3
  else
    S4
\end{verbatim}
and then recursing into the two branches.

\section{Normalizing $\lambda$-expressions}
All $\lambda$-expressions are transformed into named (local) functions. The body
of the $\lambda$-expression is an expression, but when normalized it may require
a number of preceding statements. Thus one cannot use a $\lambda$-expression.
\todo{Not implemented yet}

\section{Normalizing {\tt while}}
We only have support for {\tt while} where the condition is a single
variable. To support arbitrary conditions we would have to precede the
whole {\tt while} statement and all matching inner {\tt continue}
statements with the list of statements calculating the condition.

\section{Semantic deviation}
\paragraph{The short-circuit semantics of boolean operators are ignored;}
  instead expressions are always fully evaluated. This could be fixed
  at the cost of some output complexity, e.g. \verb|if a or b: S| should
  be normalized to
\begin{verbatim}
tmp_1 = a
tmp_2 = not tmp_1
if tmp_2: tmp_1 = b
if tmp_1: S
\end{verbatim}

\section{Experimental verification}
\todo{Run experiments with the unit tests from CPython, or if there's
  not enough time, drop this section}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Instrumentation}
\label{ch:instumentation}

We instrument the python code by inserting calls to our python
library into the source.

Example: The program
\begin{verbatim}
def foo(x):
    return 2*x
\end{verbatim}
is first normalized to
\begin{verbatim}
def foo(x):
    tmp_1 = 2
    tmp_2 = tmp_1 * x
    return tmp_2
\end{verbatim}
and then after inserting calls to our instrumentation code it becomes
\begin{verbatim}
def foo(x):
    symbolic_scope('x')
    symbolic_assign_literal('tmp_1', 2)
    tmp_1 = 2
    symbolic_assign_binop('tmp_2', '*', 'tmp_1', 'x')
    tmp_2 = tmp_1 * x
    symbolic_return('tmp_2')
    return tmp_2
\end{verbatim}

\todo{Add example with branching}

\section{Transformations}
\todo{What is this}

\begin{description}
  \item[Functions:] A call to {\tt symbolic\_scope} is inserted as the
    first statement of the function body.
  \item[{\tt while} loops:] An {\tt assert} is prepended to the body.
  \item[Conditionals:] In every {\tt then} branch an {\tt assert}
    statement is prepended. In every {\tt else} branch a {\tt refute}
    statement is prepended.
  \item[Assignment] We distinguish three kinds of assignment: literal,
    call and binop, resulting in calls to {\tt
      symbolic\_assign\_literal}, {\tt symbolic\_assign\_call} and
    {\tt symbolic\_assign\_binop} respectively. A literal assignment
    is when the right-hand-side is a literal value, e.g. a number or a
    string constant. A call assignment is an assignment where the
    right-hand-side is a function call. A binop assignment is an
    assignment where the right-hand-side is a binary operation on two
    variables.
  \item[{\tt return} statements:] Precede the statement with a call to
    {\tt symbolic\_return}. If a variable is returned (after
    normalization either a variable or nothing is returned), pass the
    name of that variable as a string to {\tt symbolic\_return}.
  \item[{\tt pass}, {\tt break} and {\tt continue} statements:] Leave
    them be.
\end{description}

\section{Supported language}
\todo{\dots}

\chapter{Symbolic execution}
\label{ch:symbolic}

\section{Overview}

\begin{itemize}
\item \todo{Inject functions into \verb|builtins|}
\item \todo{Invoke the code under test from \verb|instrument.py|}
\item \todo{Assume all errors are uncaught exceptions}
\end{itemize}

\section{Example}

Given that \verb|~/symbolic-execution/transformer/tests/pythagoras.py| contains
\begin{verbatim}
def foo(a, b, c):
    if a*a + b*b == c*c and a > 0:
        sum = a+b+c
        if 0 < sum and sum < 15 and a < b and b < c:
            res = sum / (c - b - a + 2)
\end{verbatim}

the current state of our work yields the following output

\begin{verbatim}
~/symbolic-execution/instrumentation$ python3 instrument.py
Transform /home/bondo/symbolic-execution/transformer/tests/pythagoras.py.
Transformation successful.

No error occurs when ('a', 'b', 'c') = (0, 0, 0).
Path just executed:  (('tmp_8', False),)
Next execution path: (('tmp_8', True),)
Corresponding solver: [0 == 0, Not(Not(And(a*a + b*b == c*c, a > 0)))]
Constraints are satisfiable
Model: [c = -5, b = -4, a = 3, 0 = 0] 

No error occurs when ('a', 'b', 'c') = (3, -4, -5).
Path just executed:  (('tmp_8', True), ('tmp_18', False))
Next execution path: (('tmp_8', True), ('tmp_18', True))
Corresponding solver: [0 == 0,
 15 == 15,
 And(Not(Not(And(And(And(0 < a + b + c, a + b + c < 15),
                     a < b),
                 b < c))),
     And(a*a + b*b == c*c, a > 0))]
Constraints are satisfiable
Model: [c = 5, b = 4, a = 3, 15 = 15, 0 = 0] 

When ('a', 'b', 'c') = (3, 4, 5) a ZeroDivisionError exception is
        raised: division by zero
Traceback:
  /home/bondo/symbolic-execution/transformer/tests/pythagoras.out.py
        line 54 in function foo:
    res = sum / tmp_22
Path just executed:  (('tmp_8', True), ('tmp_18', True))
No more execution paths found
\end{verbatim}

Notice that constraints like \verb|15 == 15| are added to the solver
-- this is actually a variable on the left and an integer on the
right. When assigning an integer constant as a symbolic value, we
instead assign the variable with that integer as the name. This allows
us to completely rely on Z3's symbolic representation of values. This
might change when we introduce symbolic type coercion and primitive
types other than integers and booleans. \todo{Explain output more?}

\section{Handling path conditions}
We store executed paths as a list of tuples containing \\
\verb|(symbolic_boolean_condition, variable_name, assert/refute)|.

Notice that because of the normalization, an execution path is
uniquely determined by the reduced list of \verb|(name, is_assert)|
tuples. \todo{Why?}

We find the next path to explore by this algorithm:
\begin{verbatim}
def find_next_path():
    if empty(): return None
    flip_last_condition()
    if seen_before():
        remove_last_condition()
        return find_next_path()
    return path()
\end{verbatim}

\todo{A few words about the algorithm}

\section{Handling symbolic environments}
\begin{itemize}
\item \todo{Naming arguments: Delay naming until inside the functions
  where the formals have names. Why name stuff?}
\item \todo{Scoping?}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{\todo{TODO}}

\begin{itemize}
  \item Nice diagram explaining the normalization in detail.
  \item BNF of supported language. Both for the normalization and the
    instrumentation phase.
  \item Bound execution of client code, either with a timeout or by
    the number of symbolic assertions made.
  \item Z3 can theoretically go into an infinite loop (under which
    conditions?), so set a timeout.
  \item Implement function calls in the instrumentation, both for
    local and foreign (library or external, not C) functions.
  \item Add instrumentation support for more types. First bool and
    floating point, then complex numbers, then tuples, then arrays and
    strings.
  \item Fall back on concrete values when Z3 fails.
  \item It would be nice to add constraints that force division by
    zero when possible.
\end{itemize}

\section{\LaTeX{} stuff}

\begin{itemize}
  \item A nice environment for python program text.
  \item Prettier examples.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{ch:conclusion}

\todo{\dots}

\end{document}
