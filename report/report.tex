\documentclass[11pt]{report}
%\documentclass[twoside,11pt,openright]{report}

\usepackage[utf8]{inputenc}
\usepackage[american]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{color}
\usepackage{datetime}

\renewcommand*\ttdefault{txtt}

\newcommand{\todo}[1]{{\color[rgb]{.5,0,0}\textbf{$\blacktriangleright$#1$\blacktriangleleft$}}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
{\Huge\sf Symbolic execution of Python}\\[2ex]
{\huge\sf Bjarke Bondo Andersen, 20096300}\\[2ex]
\noindent\rule{\linewidth}{1mm}\\[4ex]
\noindent{\Large\sf Project work, Computer Science\\[1ex] 
\monthname\ \the\year  \\[1ex] Advisor: Anders MÃ¸ller\\[15ex]}\\[\fill]}
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

\tableofcontents
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{ch:intro}

Symbolic execution is a way to prove existence of errors in programs. 
\todo{\dots}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Goals}
\label{ch:goals}
\todo{\dots}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Overview}
\label{ch:overview}

\begin{itemize}
  \item \todo{Implementation strategy / general design decisions}
  \item \todo{Report structure}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Background}
\label{ch:background}

\section{DART/CUTE}
\todo{\dots}

\section{Apollo}
\todo{\dots}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Normalization}
\label{ch:norm}

We do a normalization in which statements and expressions are transformed into
\emph{atomic actions}. For example, expressions are transformed into a single
action on local variables and a list of statements that assign the value of the
subexpressions into corresponding variables.

Example: \verb!a + b * 4! is transformed into the following list of
preceding statements
\begin{verbatim}
tmp_1 = 4
tmp_2 = b * tmp_1
\end{verbatim}
and the expression \verb!a + tmp_2!

\section{Supported language}
For now, only a subset of Python 3 is supported. This section will
list supported/unsupported expression and statement AST nodes.
\todo{This would probably be nicer to read this as a BNF}

\subsection{Supported expressions}
\begin{description}
  \item[Var, Int, LongInt, Float, Imaginary, Bool, Tuple, List and
    Set:] Literals of the obvious kind.
  \item[None:] The \verb|None| literal.
  \item[Ellipsis:] The \verb|Ellipsis| literal.
  \item[ByteStrings, Strings and UnicodeStrings:] String literals.
  \item[Call:] Function calls. This does not include method calls,
    which are represented as a BinOp with operator Dot. This is also
    supported, though.
  \item[BinaryOp:] The application of a binary operator. Chained
    comparisons are not supported yet.
  \item[UnaryOp:] The application of a unary operator.
  \item[Paren:] Parenthesized expressions.
\end{description}

\subsection{Unsupported expressions}
\begin{description}
  \item[Subscript:] Expressions like \verb|x[y]|.
  \item[SlicedExpr:] Expressions like \verb|w[x:y:z]|.
  \item[CondExpr:] \verb|if|-\verb|then|-\verb|else| expressions.
  \item[Lambda:] Lambda expressions.
  \item[Yield:] The \verb|Yield| operator.
  \item[Generator:] Generators.
  \item[Dictionary:] Dictionary literals.
  \item[ListComp, DictComp and SetComp:] List, dictionary and set
    comprehensions.
  \item[Starred:] Expressions prefixed by a \verb|*|.
\end{description}

\subsection{Supported statements}
\begin{description}
  \item[Import and ImportFrom:] Import statements.
  \item[While:] While loops. Only supported when the condition is a variable.
  \item[For:] For loops.
  \item[Fun:] Function declarations.
  \item[Class:] Class declarations.
  \item[Conditional:] \verb|if|-\verb|elif|-\verb|else| clains.
  \item[Assign:] Normal assignment.
  \item[AugmentedAssign:] Assignments like \verb|a += b|.
  \item[Return, Pass, Break, Continue, Global, NonLocal and Assert:] Statements of the same name.
  \item[StmtExpr:] Statements consisting of an expression.
\end{description}

\subsection{Unsupported statements}
\begin{description}
  \item[Decorated:] Decorated statements, i.e. a statement prefixed by \verb|@something|.
  \item[Try:] \verb|try|-\verb|except|-\verb|finally| statements.
  \item[Raise:] Raise an exception.
  \item[With:] Automated resource handling.
  \item[Delete:] Delete something, like the delete operator in
    ECMAScript.
  \item[Exec:] Compile and execute code on the fly, analogous to eval
    in ECMAScript.
\end{description}

\section{Normalizing {\tt if-elif-else}}
Assume we have a function $$simplifyToVariable: Expression \rightarrow
[Statement] \times Variable$$ that transforms an arbitrary expression
into a list of normalized statements, and a variable containing the
final value of the expression.

If we now have that $(stmts, var) = simplifyToVariable(t1)$, we can
normalize an \verb!if!-\verb!elif! chain
\begin{verbatim}
if t1:
  S1
elif t2:
  S2
elif t3:
  S3
else
  S4
\end{verbatim}
by first transforming it into a single \verb!if!-statement with the rest of the
\verb!if!-\verb!elif! chain in the \verb!else! clause
\begin{verbatim}
stmts
if var:
  S1
else
  if t2:
    S2
  elif t3:
    S3
  else
    S4
\end{verbatim}
and then recursing into the two branches.

\section{Normalizing $\lambda$-expressions}
All $\lambda$-expressions are transformed into named (local) functions. The body
of the $\lambda$-expression is an expression, but when normalized it may require
a number of preceding statements. Thus one cannot use a $\lambda$-expression.
\todo{Not implemented yet}

\section{Normalizing {\tt while}}
We only have support for {\tt while} where the condition is a single
variable. To support arbitrary conditions we would have to precede the
whole {\tt while} statement and all matching inner {\tt continue}
statements with the list of statements calculating the condition.

\section{Semantic deviation}
\paragraph{The short-circuit semantics of boolean operators are ignored;}
  instead expressions are always fully evaluated. This could be fixed
  at the cost of some output complexity, e.g. \verb|if a or b: S| should
  be normalized to
\begin{verbatim}
tmp_1 = a
tmp_2 = not tmp_1
if tmp_2: tmp_1 = b
if tmp_1: S
\end{verbatim}

\section{Experimental verification}
\todo{Run experiments with the unit tests from CPython, or if there's
  not enough time, drop this section}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Instrumentation}
\label{ch:instumentation}

\section{Source code transformation}
We instrumrnt the python code by inserting calls to our python
instrumentation library into the source. For example, the program
\begin{verbatim}
def foo(x):
    return 2*x
\end{verbatim}
is first normalized to
\begin{verbatim}
def foo(x):
    tmp_1 = 2
    tmp_2 = tmp_1 * x
    return tmp_2
\end{verbatim}
and then after inserting calls to our instrumentation code it becomes
\begin{verbatim}
def foo(x):
    symbolic_scope('x')
    symbolic_assign_literal('tmp_1', 2)
    tmp_1 = 2
    symbolic_assign_binop('tmp_2', '*', 'tmp_1', 'x')
    tmp_2 = tmp_1 * x
    symbolic_return('tmp_2')
    return tmp_2
\end{verbatim}

\begin{description}
  \item[Functions:] A call to {\tt symbolic\_scope} is inserted as the
    first statement of the function body.
  \item[{\tt while} loops:] An {\tt assert} is prepended to the body.
  \item[Conditionals:] In every {\tt then} branch an {\tt assert}
    statement is prepended. In every {\tt else} branch a {\tt refute}
    statement is prepended.
  \item[Assignment] We distinguish three kinds of assignment: literal,
    call and binop, resulting in calls to {\tt
      symbolic\_assign\_literal}, {\tt symbolic\_assign\_call} and
    {\tt symbolic\_assign\_binop} respectively. A literal assignment
    is when the right-hand-side is a literal value, e.g. a number or a
    string constant. A call assignment is an assignment where the
    right-hand-side is a function call. A binop assignment is an
    assignment where the right-hand-side is a binary operation on two
    variables.
  \item[{\tt return} statements:] Preceed the statement with a call to
    {\tt symbolic\_return}. If a variable is returned (after
    normalization either a variable or nothing is returned), pass the
    name of that variable as a string to {\tt symbolic\_return}.
  \item[{\tt pass}, {\tt break} and {\tt continue} statements:] Leave
    them be.
\end{description}

\section{Execution}

\subsection{Overview}

\begin{itemize}
\item Inject functions into \verb|builtins|
\item Invoke the code under test from \verb|instrument.py|
\item Assume all errors are uncaught exceptions
\item It would be nice to add constraints that force division by zero
\end{itemize}

\subsection{Example}

Given that \verb|~/symbolic-execution/transformer/tests/pythagoras.py| contains
\begin{verbatim}
def foo(a, b, c):
    if a*a + b*b == c*c and a > 0:
        sum = a+b+c
        if 0 < sum and sum < 15 and a < b and b < c:
            res = sum / (c - b - a + 2)
\end{verbatim}

the current state of out work yields the following output

\begin{verbatim}
~/symbolic-execution/instrumentation$ python3 instrument.py
Transform /home/bondo/symbolic-execution/transformer/tests/pythagoras.py.
Transformation successful.

No error occurs when ('a', 'b', 'c') = (0, 0, 0).
Path just executed:  (('tmp_8', False),)
Next execution path: (('tmp_8', True),)
Corresponding solver: [0 == 0, Not(Not(And(a*a + b*b == c*c, a > 0)))]
Constraints are satisfiable
Model: [c = -5, b = -4, a = 3, 0 = 0] 

No error occurs when ('a', 'b', 'c') = (3, -4, -5).
Path just executed:  (('tmp_8', True), ('tmp_18', False))
Next execution path: (('tmp_8', True), ('tmp_18', True))
Corresponding solver: [0 == 0,
 15 == 15,
 And(Not(Not(And(And(And(0 < a + b + c, a + b + c < 15),
                     a < b),
                 b < c))),
     And(a*a + b*b == c*c, a > 0))]
Constraints are satisfiable
Model: [c = 5, b = 4, a = 3, 15 = 15, 0 = 0] 

When ('a', 'b', 'c') = (3, 4, 5) a ZeroDivisionError exception is raised: division by zero
Traceback:
  /home/bondo/symbolic-execution/transformer/tests/pythagoras.out.py line 54 in function foo:
    res = sum / tmp_22
Path just executed:  (('tmp_8', True), ('tmp_18', True))
No more execution paths found
\end{verbatim}

Notice that constraints like \verb|15 == 15| are added to the solver
-- this is actually a variable on the left and an integer on the
right. When assigning an integer constant as a symbolic value, we
instead assign the variable with that integer as the name. This allows
us to completely rely on Z3's symbolic representation of values. This
might change when we introduce symbolic type coercion and primitive
types other than integers and booleans.

\subsection{Handeling path conditions}
We store executed paths as a list of tuples containing
$$(symbolic\_boolean\_condition, variable\_name, assert/refute)$$
Notice that because of the normalization, an execution path is
uniquely determined by the reduced list of $(name, is\_assert)$
tuples.

We find the next path to explore by this algorithm:
\begin{verbatim}
def find_next_path():
    if empty(): return None
    flip_last_condition()
    if seen_before():
        remove_last_condition()
        return find_next_path()
    return path()
\end{verbatim}

\subsection{Handeling symbolic environments}
\begin{itemize}
\item Naming arguments: Delay naming until inside the functions where
  the formals have names.
\item Scoping
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{\todo{TODO}}

\begin{itemize}
  \item Nice diagram explaining the normalization in detail.
  \item BNF of supported language.
  \item Experimental verification of our normalization.
\end{itemize}

\section{\LaTeX{} stuff}

\begin{itemize}
  \item A nice environment for python program text.
  \item Prettier examples.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{ch:conclusion}

\todo{\dots}

\end{document}
