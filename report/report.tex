\documentclass[a4paper]{article}
\begin{document}

\section*{Introduction}

Symbolic execution is a way to prove existence of errors in programs. 

Symbolic values, constraint solving, etc.

\section*{Goals}

\section*{Overview}

\section*{Normalization}

We do a normalization in which statements and expressions are transformed into
\emph{atomic actions}. For example, expressions are transformed into a single
action on local variables and a list of statements that assign the value of the
subexpressions into corresponding variables.

Example: \verb!a + b * 4! is transformed into the following list of
preceding statements
\begin{verbatim}
tmp_1 = 4
tmp_2 = b * tmp_1
\end{verbatim}
and the expression \verb!a + tmp_2!

\subsection*{Normalizing {\tt if-elif-else}}
Assume we have a function $$simplifyToVariable: Expression \rightarrow
[Statement] \times Variable$$ that transforms an arbitrary expression
into a list of normalized statements, and a variable containing the
final value of the expression.

If we now have that $(stmts, var) = simplifyToVariable(t1)$, we can
normalize an \verb!if!-\verb!elif! chain
\begin{verbatim}
if t1:
  S1
elif t2:
  S2
elif t3:
  S3
else
  S4
\end{verbatim}
by first transforming it into a single \verb!if!-statement with the rest of the
\verb!if!-\verb!elif! chain in the \verb!else! clause
\begin{verbatim}
stmts
if var:
  S1
else
  if t2:
    S2
  elif t3:
    S3
  else
    S4
\end{verbatim}
and then recursing into the two branches.

\subsection*{Normalizing $\lambda$-expressions}
All $\lambda$-expressions are transformed into named (local) functions. The body
of the $\lambda$-expression is an expression, but when normalized it may require
a number of preceding statements. Thus one cannot use a $\lambda$-expression.

\subsection*{Normalizing {\tt while}}
We only have support for {\tt while} where the condition is a single
variable. To support arbitrary conditions we would have to precede the
whole {\tt while} statement and all matching inner {\tt continue}
statements with the list of statements calculating the condition.

\subsection*{Experimental verification}

\section*{Instrumentation}

\subsection*{Source code transformation}
We instrumrnt the python code by inserting calls to our python
instrumentation library into the source. For example, the program
\begin{verbatim}
def foo(x):
    return 2*x
\end{verbatim}
is first normalized to
\begin{verbatim}
def foo(x):
    tmp_1 = 2
    tmp_2 = tmp_1 * x
    return tmp_2
\end{verbatim}
and then after inserting calls to our instrumentation code it becomes
\begin{verbatim}
def foo(x):
    symbolic_scope('x')
    symbolic_assign_literal('tmp_1', 2)
    tmp_1 = 2
    symbolic_assign_binop('tmp_2', '*', 'tmp_1', 'x')
    tmp_2 = tmp_1 * x
    symbolic_return('tmp_2')
    return tmp_2
\end{verbatim}

\begin{description}
  \item[Functions:] A call to {\tt symbolic\_scope} is inserted as the
    first statement of the function body.
  \item[{\tt while} loops:] An {\tt assert} is prepended to the body.
  \item[Conditionals:] In every {\tt then} branch an {\tt assert}
    statement is prepended. In every {\tt else} branch a {\tt refute}
    statement is prepended.
  \item[Assignment] We distinguish three kinds of assignment: literal,
    call and binop, resulting in calls to {\tt
      symbolic\_assign\_literal}, {\tt symbolic\_assign\_call} and
    {\tt symbolic\_assign\_binop} respectively. A literal assignment
    is when the right-hand-side is a literal value, e.g. a number or a
    string constant. A call assignment is an assignment where the
    right-hand-side is a function call. A binop assignment is an
    assignment where the right-hand-side is a binary operation on two
    variables.
  \item[{\tt return} statements:] Preceed the statement with a call to
    {\tt symbolic\_return}. If a variable is returned (after
    normalization either a variable or nothing is returned), pass the
    name of that variable as a string to {\tt symbolic\_return}.
  \item[{\tt pass}, {\tt break} and {\tt continue} statements:] Leave
    them be.
\end{description}

\subsection*{Execution}
Given that \verb|~/symbolic-execution/transformer/tests/pythagoras.py| contains
\begin{verbatim}
def foo(a, b, c):
    if a*a + b*b == c*c and a > 0:
        sum = a+b+c
        if 0 < sum and sum < 15 and a < b and b < c:
            res = sum / (c - b - a + 2)
\end{verbatim}

the current state of out work yields the following output

\begin{verbatim}
~/symbolic-execution/instrumentation$ python3 instrument.py
Transform /home/bondo/symbolic-execution/transformer/tests/pythagoras.py.
Transformation successful.

No error occurs when ('a', 'b', 'c') = (0, 0, 0).
Path just executed:  (('tmp_8', False),)
Next execution path: (('tmp_8', True),)
Corresponding solver: [0 == 0, Not(Not(And(a*a + b*b == c*c, a > 0)))]
Constraints are satisfiable
Model: [c = -5, b = -4, a = 3, 0 = 0] 

No error occurs when ('a', 'b', 'c') = (3, -4, -5).
Path just executed:  (('tmp_8', True), ('tmp_18', False))
Next execution path: (('tmp_8', True), ('tmp_18', True))
Corresponding solver: [0 == 0,
 15 == 15,
 And(Not(Not(And(And(And(0 < a + b + c, a + b + c < 15),
                     a < b),
                 b < c))),
     And(a*a + b*b == c*c, a > 0))]
Constraints are satisfiable
Model: [c = 5, b = 4, a = 3, 15 = 15, 0 = 0] 

When ('a', 'b', 'c') = (3, 4, 5) a ZeroDivisionError exception is raised: division by zero
Traceback:
  /home/bondo/symbolic-execution/transformer/tests/pythagoras.out.py line 54 in function foo:
    res = sum / tmp_22
Path just executed:  (('tmp_8', True), ('tmp_18', True))
No more execution paths found
\end{verbatim}

\section*{Related work}

\subsection*{DART}

\subsection*{Apollo}

\section*{Future work}

\begin{itemize}
  \item Nice diagram explaining the normalization in detail.
  \item Instrumentation of code
  \item Library for symbolic execution
  \item Introduction 
  \item Experimental verification of our normalization
  \item Sprinkle with examples! \textbackslash{}o/
  \item \LaTeX{} stuff
  \item Roadmap
  \item Small test programs for experimental verification of the normalization
  \item Test programs for the final symbolic execution test
\end{itemize}

\subsection*{\LaTeX{} stuff}

\begin{itemize}
  \item A nice environment for python program text.
  \item Something something for examples.
\end{itemize}

\subsection*{Roadmap}

TODO

\end{document}


